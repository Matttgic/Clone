name: Generate Team Mapping (Format Fixed)

on:
  workflow_dispatch:
    inputs:
      season:
        description: 'Season (YYYY format)'
        required: false
        default: '2024'
        type: string

permissions:
  contents: write

jobs:
  generate-mapping:
    runs-on: ubuntu-latest
    env:
      PYTHONPATH: ${{ github.workspace }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Generate team mapping with dual format support
        env:
          RAPIDAPI_KEY: ${{ secrets.RAPIDAPI_KEY }}
          SEASON: ${{ inputs.season }}
        run: |
          mkdir -p output
          
          cat > scripts/dual_format_mapping.py << 'EOF'
          import requests
          import pandas as pd
          import json
          import os
          import time
          from datetime import datetime
          from difflib import SequenceMatcher
          from config.settings import Settings
          from config.leagues import ALLOWED_LEAGUES
          from config.league_mapping import LEAGUE_CODE_TO_API_ID
          
          def detect_csv_format_and_extract_teams(csv_url, league_code):
              """DÃ©tecte le format du CSV et extrait les Ã©quipes"""
              try:
                  print(f"    ðŸŒ Downloading CSV: {csv_url}")
                  df = pd.read_csv(csv_url)
                  
                  print(f"    ðŸ“Š CSV shape: {df.shape}")
                  print(f"    ðŸ“‹ Columns found: {list(df.columns)}")
                  
                  teams = set()
                  
                  # Format 1: HomeTeam/AwayTeam (ligues europÃ©ennes classiques)
                  if 'HomeTeam' in df.columns and 'AwayTeam' in df.columns:
                      print(f"    ðŸ“‹ Using HomeTeam/AwayTeam format")
                      teams.update(df['HomeTeam'].dropna().unique())
                      teams.update(df['AwayTeam'].dropna().unique())
                  
                  # Format 2: Home/Away (ligues "current")
                  elif 'Home' in df.columns and 'Away' in df.columns:
                      print(f"    ðŸ“‹ Using Home/Away format")
                      teams.update(df['Home'].dropna().unique())
                      teams.update(df['Away'].dropna().unique())
                  
                  # Autres formats possibles
                  elif 'home_team' in df.columns and 'away_team' in df.columns:
                      print(f"    ðŸ“‹ Using home_team/away_team format")
                      teams.update(df['home_team'].dropna().unique())
                      teams.update(df['away_team'].dropna().unique())
                  
                  else:
                      available_cols = [col for col in df.columns if 'team' in col.lower() or 'home' in col.lower() or 'away' in col.lower()]
                      error_msg = f"No recognized team columns. Available team-related columns: {available_cols}"
                      print(f"    âŒ {error_msg}")
                      return [], error_msg
                  
                  # Nettoyer la liste des Ã©quipes
                  clean_teams = []
                  for team in teams:
                      if team and str(team).strip() and str(team).strip() != 'nan':
                          clean_teams.append(str(team).strip())
                  
                  print(f"    âœ… Extracted {len(clean_teams)} unique teams")
                  if clean_teams:
                      print(f"    ðŸ“ Sample teams: {clean_teams[:5]}")
                  
                  return clean_teams, None
                  
              except Exception as e:
                  error_msg = f"Error processing CSV {csv_url}: {str(e)}"
                  print(f"    âŒ {error_msg}")
                  return [], error_msg
          
          def normalize_team_name(name):
              """Normalisation avancÃ©e des noms d'Ã©quipe"""
              if not name or not isinstance(name, str):
                  return ""
              
              # Remplacements spÃ©cifiques connus
              known_mappings = {
                  # Premier League
                  "Man United": "Manchester United",
                  "Man City": "Manchester City",
                  "Spurs": "Tottenham Hotspur",
                  "Leicester": "Leicester City",
                  "Brighton": "Brighton & Hove Albion",
                  "Wolves": "Wolverhampton Wanderers",
                  "Newcastle": "Newcastle United",
                  "West Ham": "West Ham United",
                  "Nott'm Forest": "Nottingham Forest",
                  "Sheffield United": "Sheffield Utd",
                  
                  # La Liga
                  "Ath Madrid": "Atletico Madrid",
                  "Ath Bilbao": "Athletic Bilbao",
                  "Betis": "Real Betis",
                  "Sociedad": "Real Sociedad",
                  "Vallecano": "Rayo Vallecano",
                  "Cadiz": "Cadiz CF",
                  
                  # Bundesliga
                  "Bayern Munich": "Bayern MÃ¼nchen",
                  "Dortmund": "Borussia Dortmund",
                  "RB Leipzig": "RasenBallsport Leipzig",
                  "Leverkusen": "Bayer Leverkusen",
                  "M'gladbach": "Borussia MÃ¶nchengladbach",
                  "Ein Frankfurt": "Eintracht Frankfurt",
                  "Hoffenheim": "TSG Hoffenheim",
                  
                  # Serie A
                  "Inter": "Inter Milan",
                  "AC Milan": "Milan",
                  "Roma": "AS Roma",
                  "Lazio": "SS Lazio",
                  "Napoli": "SSC Napoli",
                  "Atalanta": "Atalanta BC",
                  
                  # Ligue 1
                  "Paris SG": "Paris Saint Germain",
                  "Saint-Etienne": "AS Saint Etienne",
                  "Marseille": "Olympique Marseille",
                  "Lyon": "Olympique Lyonnais",
                  "Nice": "OGC Nice",
              }
              
              # VÃ©rifier les mappings directs
              if name in known_mappings:
                  return known_mappings[name]
              
              # Normalisation gÃ©nÃ©rale
              normalized = name
              
              # Suppression des prÃ©fixes/suffixes courants
              prefixes_suffixes = [
                  ("FC ", ""), (" FC", ""), ("CF ", ""), (" CF", ""),
                  ("AC ", ""), (" AC", ""), ("SC ", ""), (" SC", ""),
                  ("AS ", ""), (" AS", ""), ("CD ", ""), (" CD", ""),
                  ("SK ", ""), (" SK", ""), ("FK ", ""), (" FK", ""),
                  ("1. ", ""), ("2. ", ""), ("SV ", ""), (" SV", ""),
                  ("Real ", ""), ("Club ", ""), ("Deportivo ", ""),
                  ("Athletic ", ""), ("Atletico ", "Atletico "),
                  ("Borussia ", ""), ("Olympique ", ""),
                  ("Saint ", "St "), ("Saint-", "St-"),
              ]
              
              for old, new in prefixes_suffixes:
                  normalized = normalized.replace(old, new)
              
              # Nettoyage des caractÃ¨res spÃ©ciaux
              char_replacements = [
                  ("Ã¼", "u"), ("Ã¶", "o"), ("Ã¤", "a"), ("ÃŸ", "ss"),
                  ("Ã©", "e"), ("Ã¨", "e"), ("Ãª", "e"), ("Ã«", "e"),
                  ("Ã ", "a"), ("Ã¡", "a"), ("Ã¢", "a"), ("Ã£", "a"),
                  ("Ã§", "c"), ("Ã±", "n"), ("Ã¸", "o"), ("Ã¥", "a"),
                  ("  ", " "), ("   ", " "),  # espaces multiples
              ]
              
              for old, new in char_replacements:
                  normalized = normalized.replace(old, new)
              
              return normalized.strip()
          
          def calculate_similarity(name1, name2):
              """Calcule la similaritÃ© entre deux noms d'Ã©quipe"""
              if not name1 or not name2:
                  return 0.0
              
              # Normaliser les deux noms
              norm1 = normalize_team_name(name1).lower()
              norm2 = normalize_team_name(name2).lower()
              
              # Match exact aprÃ¨s normalisation
              if norm1 == norm2:
                  return 1.0
              
              # Un nom contient l'autre
              if norm1 in norm2 or norm2 in norm1:
                  return 0.9
              
              # Mots en commun
              words1 = set(norm1.split())
              words2 = set(norm2.split())
              
              if words1 and words2:
                  common_words = len(words1.intersection(words2))
                  total_words = len(words1.union(words2))
                  if total_words > 0:
                      word_similarity = common_words / total_words
                      if word_similarity > 0.5:
                          return max(0.8, word_similarity)
              
              # SimilaritÃ© de chaÃ®ne standard
              return SequenceMatcher(None, norm1, norm2).ratio()
          
          def match_teams_comprehensive(fd_teams, api_teams, league_code):
              """Matching complet avec plusieurs niveaux"""
              matches = []
              unmatched_fd = []
              
              print(f"    ðŸ”„ Matching {len(fd_teams)} FD teams with {len(api_teams)} API teams for {league_code}")
              
              for fd_team in fd_teams:
                  best_match = None
                  best_score = 0.0
                  best_api_team = None
                  match_details = []
                  
                  for api_team in api_teams:
                      score = calculate_similarity(fd_team, api_team["name"])
                      match_details.append((api_team["name"], score))
                      
                      if score > best_score:
                          best_score = score
                          best_match = api_team["name"]
                          best_api_team = api_team
                  
                  # Debug: montrer les top 3 matches
                  top_matches = sorted(match_details, key=lambda x: x[1], reverse=True)[:3]
                  
                  # Seuil adaptatif selon la confiance
                  threshold = 0.6  # Seuil de base
                  if best_score >= threshold:
                      matches.append({
                          "fd_team": fd_team,
                          "api_team": best_match,
                          "api_team_id": best_api_team["id"],
                          "confidence": round(best_score, 3),
                          "match_type": "exact" if best_score >= 0.95 else "similarity"
                      })
                      print(f"      âœ… '{fd_team}' â†’ '{best_match}' (conf: {best_score:.3f})")
                  else:
                      unmatched_fd.append(fd_team)
                      print(f"      âŒ '{fd_team}' â†’ No good match (best: '{best_match}' at {best_score:.3f})")
                      print(f"         Top candidates: {[(name, f'{score:.3f}') for name, score in top_matches[:2]]}")
              
              return matches, unmatched_fd
          
          def main():
              print("ðŸ Starting dual-format team mapping...")
              
              settings = Settings()
              season = int(os.getenv("SEASON", "2024"))
              
              report = {
                  "metadata": {
                      "generated_at": datetime.now().isoformat(),
                      "season": season,
                      "total_leagues_processed": 0,
                      "total_teams_mapped": 0,
                      "api_calls_made": 0,
                      "success_rate": 0.0
                  },
                  "leagues": {},
                  "mapping_details": {},
                  "errors": []
              }
              
              team_mapping = {}
              
              # Charger les sources
              try:
                  with open('config/fd_sources.json', 'r') as f:
                      sources = json.load(f)["sources"]
                  print(f"ðŸ“‹ {len(sources)} sources loaded")
              except Exception as e:
                  print(f"âŒ Error loading sources: {e}")
                  report["errors"].append(f"Error loading sources: {e}")
                  return team_mapping, report
              
              successful_leagues = 0
              
              for i, source in enumerate(sources):
                  league_code = source["league_code"]
                  print(f"\nðŸ† Processing {i+1}/{len(sources)}: {league_code}")
                  
                  # VÃ©rifications prÃ©liminaires
                  if league_code not in LEAGUE_CODE_TO_API_ID:
                      print(f"â­ï¸  {league_code}: Not in league mapping")
                      continue
                  
                  league_id = LEAGUE_CODE_TO_API_ID[league_code]
                  if league_id is None:
                      print(f"â­ï¸  {league_code}: League ID is None")
                      continue
                  
                  # VÃ©rifier si la ligue est autorisÃ©e
                  league_name = None
                  for name, id_val in ALLOWED_LEAGUES.items():
                      if id_val == league_id:
                          league_name = name
                          break
                  
                  if not league_name:
                      print(f"â­ï¸  {league_code}: League ID {league_id} not in allowed leagues")
                      continue
                  
                  try:
                      # Pause pour Ã©viter rate limiting
                      if i > 0:
                          time.sleep(0.5)
                      
                      # 1. RÃ©cupÃ©rer les Ã©quipes via l'API
                      print(f"    ðŸ“¡ Getting API standings for league {league_id}")
                      url = f"{settings.API.BASE_URL}/standings"
                      params = {"league": league_id, "season": season}
                      response = requests.get(url, headers=settings.API.headers, params=params)
                      report["metadata"]["api_calls_made"] += 1
                      
                      if response.status_code != 200:
                          error_msg = f"API error {response.status_code} for {league_code}"
                          print(f"    âŒ {error_msg}")
                          report["errors"].append(error_msg)
                          continue
                      
                      # Parser la rÃ©ponse API
                      data = response.json()
                      api_teams = []
                      
                      if data.get("response") and len(data["response"]) > 0:
                          standings = data["response"][0]["league"]["standings"]
                          
                          if isinstance(standings[0], list):
                              # Format avec groupes (Champions League, etc.)
                              for group in standings:
                                  for team_data in group:
                                      api_teams.append({
                                          "name": team_data["team"]["name"],
                                          "id": team_data["team"]["id"]
                                      })
                          else:
                              # Format standard
                              for team_data in standings:
                                  api_teams.append({
                                      "name": team_data["team"]["name"],
                                      "id": team_data["team"]["id"]
                                  })
                      
                      print(f"    âœ… Found {len(api_teams)} API teams")
                      
                      # 2. RÃ©cupÃ©rer les Ã©quipes depuis le CSV Football Data
                      fd_teams, csv_error = detect_csv_format_and_extract_teams(source["url"], league_code)
                      
                      if csv_error:
                          report["errors"].append(f"{league_code}: {csv_error}")
                          continue
                      
                      if not fd_teams:
                          print(f"    âŒ No FD teams found")
                          continue
                      
                      # 3. Faire le matching
                      matches, unmatched = match_teams_comprehensive(fd_teams, api_teams, league_code)
                      
                      if matches:
                          # CrÃ©er le mapping pour cette ligue
                          mapping = {}
                          for match in matches:
                              mapping[match["fd_team"]] = match["api_team"]
                          
                          team_mapping[str(league_id)] = mapping
                          successful_leagues += 1
                          
                          success_rate = len(matches) / len(fd_teams) * 100
                          
                          report["leagues"][league_code] = {
                              "name": league_name,
                              "id": league_id,
                              "status": "success",
                              "fd_teams_count": len(fd_teams),
                              "api_teams_count": len(api_teams),
                              "mapped_count": len(matches),
                              "success_rate": round(success_rate, 1),
                              "matches": matches,
                              "unmatched_fd": unmatched
                          }
                          
                          print(f"    âœ… Successfully mapped {len(matches)}/{len(fd_teams)} teams ({success_rate:.1f}%)")
                          
                          if unmatched:
                              print(f"    âš ï¸  Unmatched FD teams: {unmatched}")
                      else:
                          report["leagues"][league_code] = {
                              "name": league_name,
                              "id": league_id,
                              "status": "no_matches",
                              "fd_teams_count": len(fd_teams),
                              "api_teams_count": len(api_teams),
                              "fd_teams_sample": fd_teams[:5],
                              "api_teams_sample": [team["name"] for team in api_teams[:5]]
                          }
                          print(f"    âŒ No matches found")
                  
                  except Exception as e:
                      error_msg = f"Error processing {league_code}: {str(e)}"
                      print(f"    âŒ {error_msg}")
                      report["errors"].append(error_msg)
              
              # Finaliser le rapport
              report["metadata"]["total_leagues_processed"] = successful_leagues
              report["metadata"]["total_teams_mapped"] = sum(len(teams) for teams in team_mapping.values())
              
              if len(sources) > 0:
                  report["metadata"]["success_rate"] = round(successful_leagues / len(sources) * 100, 1)
              
              print(f"\nðŸŽ‰ Mapping completed:")
              print(f"   ðŸ“Š {successful_leagues}/{len(sources)} leagues successfully processed")
              print(f"   ðŸŸï¸  {report['metadata']['total_teams_mapped']} teams mapped total")
              print(f"   ðŸ“¡ {report['metadata']['api_calls_made']} API calls made")
              print(f"   ðŸŽ¯ Overall success rate: {report['metadata']['success_rate']}%")
              
              return team_mapping, report
          
          def save_comprehensive_results(team_mapping, report):
              """Sauvegarde tous les rÃ©sultats"""
              try:
                  # 1. Mapping principal (format utilisable)
                  with open("output/team_mapping.json", "w", encoding="utf-8") as f:
                      json.dump(team_mapping, f, indent=2, ensure_ascii=False)
                  print("âœ… team_mapping.json saved")
                  
                  # 2. Rapport dÃ©taillÃ© complet
                  with open("output/detailed_report.json", "w", encoding="utf-8") as f:
                      json.dump(report, f, indent=2, ensure_ascii=False)
                  print("âœ… detailed_report.json saved")
                  
                  # 3. CSV avec tous les dÃ©tails
                  csv_data = []
                  for league_code, league_info in report["leagues"].items():
                      if league_info["status"] == "success" and "matches" in league_info:
                          for match in league_info["matches"]:
                              csv_data.append({
                                  "league_code": league_code,
                                  "league_name": league_info["name"],
                                  "league_id": league_info["id"],
                                  "fd_team_name": match["fd_team"],
                                  "api_team_name": match["api_team"],
                                  "api_team_id": match["api_team_id"],
                                  "confidence_score": match["confidence"],
                                  "match_type": match["match_type"]
                              })
                  
                  if csv_data:
                      df_mapping = pd.DataFrame(csv_data)
                      df_mapping.to_csv("output/complete_team_mapping.csv", index=False)
                      print(f"âœ… complete_team_mapping.csv saved ({len(csv_data)} mappings)")
                  
                  # 4. CSV des Ã©quipes non matchÃ©es
                  unmatched_data = []
                  for league_code, league_info in report["leagues"].items():
                      if "unmatched_fd" in league_info and league_info["unmatched_fd"]:
                          for team in league_info["unmatched_fd"]:
                              unmatched_data.append({
                                  "league_code": league_code,
                                  "league_name": league_info["name"],
                                  "league_id": league_info["id"],
                                  "unmatched_fd_team": team
                              })
                  
                  if unmatched_data:
                      df_unmatched = pd.DataFrame(unmatched_data)
                      df_unmatched.to_csv("output/unmatched_teams.csv", index=False)
                      print(f"âœ… unmatched_teams.csv saved ({len(unmatched_data)} unmatched)")
                  
                  return True
              except Exception as e:
                  print(f"âŒ Error saving results: {e}")
                  return False
          
          if __name__ == "__main__":
              try:
                  mapping, report = main()
                  success = save_comprehensive_results(mapping, report)
                  
                  if success:
                      print("\nðŸŽ‰ All files generated successfully!")
                  else:
                      print("\nâŒ Some files failed to generate")
                      exit(1)
                      
              except Exception as e:
                  print(f"âŒ Script failed: {e}")
                  import traceback
                  traceback.print_exc()
                  exit(1)
          EOF
          
          # ExÃ©cuter le script
          python -u scripts/dual_format_mapping.py

      - name: Create comprehensive report
        if: always()
        run: |
          cat > create_final_report.py << 'EOF'
          import json
          import os
          
          def create_final_report():
              if not os.path.exists('output/detailed_report.json'):
                  return "# âŒ Detailed report not found"
              
              with open('output/detailed_report.json', 'r') as f:
                  report = json.load(f)
              
              lines = []
              lines.append("# ðŸ† Team Mapping Generation Report")
              lines.append("")
              lines.append(f"**Generated:** {report['metadata']['generated_at']}")
              lines.append(f"**Season:** {report['metadata']['season']}")
              lines.append("")
              
              # Statistiques globales
              meta = report['metadata']
              lines.append("## ðŸ“Š Global Statistics")
              lines.append("")
              lines.append(f"- **Total leagues processed:** {meta['total_leagues_processed']}")
              lines.append(f"- **Total teams mapped:** {meta['total_teams_mapped']}")
              lines.append(f"- **API calls made:** {meta['api_calls_made']}")
              lines.append(f"- **Overall success rate:** {meta['success_rate']}%")
              lines.append("")
              
              # RÃ©sumÃ© par ligue
              lines.append("## ðŸŸï¸ League-by-League Results")
              lines.append("")
              lines.append("| League | Name | Status | FD Teams | API Teams | Mapped | Success Rate |")
              lines.append("|--------|------|--------|----------|-----------|---------|--------------|")
              
              successful = 0
              for code, info in report['leagues'].items():
                  status_icon = "âœ…" if info['status'] == 'success' else "âŒ"
                  fd_count = info.get('fd_teams_count', 0)
                  api_count = info.get('api_teams_count', 0)
                  mapped_count = info.get('mapped_count', 0)
                  success_rate = info.get('success_rate', 0)
                  
                  if info['status'] == 'success':
                      successful += 1
                  
                  lines.append(f"| {code} | {info['name']} | {status_icon} | {fd_count} | {api_count} | {mapped_count} | {success_rate}% |")
              
              lines.append("")
              lines.append(f"**Summary:** {successful} successful leagues out of {len(report['leagues'])}")
              lines.append("")
              
              # Exemples de mappings rÃ©ussis
              lines.append("## âœ… Successful Mappings (Examples)")
              lines.append("")
              
              example_count = 0
              for code, info in report['leagues'].items():
                  if info['status'] == 'success' and 'matches' in info and example_count < 5:
                      lines.append(f"### {code} - {info['name']}")
                      lines.append("")
                      lines.append("| Football Data Name | API Name | Confidence |")
                      lines.append("|--------------------|----------|------------|")
                      
                      # Montrer les 10 premiers matches
                      for match in info['matches'][:10]:
                          conf = match['confidence']
                          lines.append(f"| {match['fd_team']} | {match['api_team']} | {conf} |")
                      
                      if len(info['matches']) > 10:
                          lines.append(f"| ... | ... | ... |")
                          lines.append(f"| ({len(info['matches']) - 10} more matches) | | |")
                      
                      lines.append("")
                      example_count += 1
              
              # ProblÃ¨mes rencontrÃ©s
              if report.get('errors'):
                  lines.append("## âŒ Issues Encountered")
                  lines.append("")
                  for error in report['errors'][:15]:  # Limit to 15 errors
                      lines.append(f"- {error}")
                  lines.append("")
              
              # Instructions d'utilisation
              lines.append("## ðŸ“– How to Use the Mapping")
              lines.append("")
              lines.append("The main output file is `team_mapping.json`. Here's how to use it:")
              lines.append("")
              lines.append("```python")
              lines.append("import json")
              lines.append("")
              lines.append("# Load the mapping")
              lines.append("with open('team_mapping.json', 'r') as f:")
              lines.append("    mapping = json.load(f)")
              lines.append("")
              lines.append("# Convert Football Data team name to API team name")
              lines.append("def get_api_team_name(league_id, fd_team_name):")
              lines.append("    league_str = str(league_id)")
              lines.append("    if league_str in mapping:")
              lines.append("        return mapping[league_str].get(fd_team_name, fd_team_name)")
              lines.append("    return fd_team_name")
              lines.append("")
              lines.append("# Example usage")
              lines.append("league_id = 39  # Premier League")
              lines.append("fd_name = 'Man United'")
              lines.append("api_name = get_api_team_name(league_id, fd_name)")
              lines.append("print(f'{fd_name} -> {api_name}')  # Man United -> Manchester United")
              lines.append("```")
              lines.append("")
              
              # Fichiers gÃ©nÃ©rÃ©s
              lines.append("## ðŸ“ Generated Files")
              lines.append("")
              files_info = [
                  ("team_mapping.json", "Main mapping file for use in your code"),
                  ("detailed_report.json", "Complete technical report with all details"),
                  ("complete_team_mapping.csv", "All mappings in CSV format"),
                  ("unmatched_teams.csv", "Teams that couldn't be matched"),
                  ("FINAL_REPORT.md", "This human-readable report")
              ]
              
              for filename, description in files_info:
                  if os.path.exists(f'output/{filename}'):
                      lines.append(f"- âœ… `{filename}` - {description}")
                  else:
                      lines.append(f"- âŒ `{filename}` - {description} (not generated)")
              
              return "\n".join(lines)
          
          # GÃ©nÃ©rer le rapport
          report_content = create_final_report()
          with open("output/FINAL_REPORT.md", "w", encoding="utf-8") as f:
              f.write(report_content)
          print("âœ… Final report generated: FINAL_REPORT.md")
          EOF
          
          python create_final_report.py

      - name: Upload all results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: team-mapping-complete
          path: output/
          retention-days: 30

      - name: Display final summary
        if: always()
        run: |
          echo "## ðŸŽ‰ Team Mapping Generation Complete!" >> $GITHUB_STEP_SUMMARY
          
          if [ -f "output/detailed_report.json" ]; then
              # Extraire les statistiques du rapport
              STATS=$(python -c "
          import json
          try:
              with open('output/detailed_report.json', 'r') as f:
                  report = json.load(f)
              meta = report['metadata']
              print(f'SUCCESS|{meta[\"total_leagues_processed\"]}|{meta[\"total_teams_mapped\"]}|{meta[\"api_calls_made\"]}|{meta[\"success_rate\"]}')
          except:
              print('ERROR|0|0|0|0')
              " 2>/dev/null)
             
             IFS='|' read -r STATUS LEAGUES TEAMS CALLS SUCCESS_RATE <<< "$STATS"
             
             if [ "$STATUS" = "SUCCESS" ]; then
                 echo "âœ… **Status:** Successfully completed!" >> $GITHUB_STEP_SUMMARY
                 echo "ðŸ“Š **Leagues processed:** $LEAGUES" >> $GITHUB_STEP_SUMMARY
                 echo "ðŸŸï¸ **Teams mapped:** $TEAMS" >> $GITHUB_STEP_SUMMARY
                 echo "ðŸ“¡ **API calls made:** $CALLS" >> $GITHUB_STEP_SUMMARY
                 echo "ðŸŽ¯ **Success rate:** $SUCCESS_RATE%" >> $GITHUB_STEP_SUMMARY
                 echo "" >> $GITHUB_STEP_SUMMARY
                 
                 # Afficher les ligues les plus rÃ©ussies
                 echo "ðŸ† **Top successful leagues:**" >> $GITHUB_STEP_SUMMARY
                 python -c "
         import json
         with open('output/detailed_report.json', 'r') as f:
             report = json.load(f)
         
         successful = []
         for code, info in report['leagues'].items():
             if info['status'] == 'success':
                 successful.append((code, info['name'], info['mapped_count'], info['success_rate']))
         
         # Trier par nombre d'Ã©quipes mappÃ©es
         successful.sort(key=lambda x: x[2], reverse=True)
         
         for code, name, mapped, rate in successful[:5]:
             print(f'- **{code}** ({name}): {mapped} teams ({rate}%)')
         " >> $GITHUB_STEP_SUMMARY
             else
                 echo "âŒ **Status:** Failed to generate mapping" >> $GITHUB_STEP_SUMMARY
                 echo "Check the workflow logs for error details." >> $GITHUB_STEP_SUMMARY
             fi
         else
             echo "âŒ **Status:** No report file generated" >> $GITHUB_STEP_SUMMARY
         fi
         
         echo "" >> $GITHUB_STEP_SUMMARY
         echo "ðŸ“ **Generated files:**" >> $GITHUB_STEP_SUMMARY
         
         if [ -d "output" ]; then
             ls -la output/ | tail -n +2 | while read -r line; do
                 filename=$(echo "$line" | awk '{print $9}')
                 filesize=$(echo "$line" | awk '{print $5}')
                 if [ "$filename" != "." ] && [ "$filename" != ".." ]; then
                     echo "- \`$filename\` (${filesize} bytes)" >> $GITHUB_STEP_SUMMARY
                 fi
             done
         else
             echo "- No output directory created" >> $GITHUB_STEP_SUMMARY
         fi
         
         echo "" >> $GITHUB_STEP_SUMMARY
         echo "ðŸš€ **Next steps:**" >> $GITHUB_STEP_SUMMARY
         echo "1. Download the artifacts from this workflow run" >> $GITHUB_STEP_SUMMARY
         echo "2. Extract \`team_mapping.json\` to your \`config/\` directory" >> $GITHUB_STEP_SUMMARY
         echo "3. Use the mapping in your prediction scripts" >> $GITHUB_STEP_SUMMARY
         echo "4. Check \`FINAL_REPORT.md\` for detailed usage instructions" >> $GITHUB_STEP_SUMMARY
